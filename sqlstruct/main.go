package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/inysc/astool/pkg"
)

var (
	filename  string
	typeInput string
	// fileInput string
	types []string
	// files     []string
)

func init() {
	flag.StringVar(&filename, "file", "", "")
	flag.StringVar(&typeInput, "types", "", "")
	// flag.StringVar(&fileInput, "files", "", "")
	flag.Parse()
	for _, v := range strings.Split(typeInput, ",") {
		types = append(types, strings.TrimSpace(v))
	}
	// for _, v := range strings.Split(fileInput, ",") {
	// 	files = append(files, strings.TrimSpace(v))
	// }
}

const SQLNames = `
func (i *%s) SQLNames() []string {
	return []string{%s}
}
`

const SQLValues = `
func (i *%s) SQLValues() []any {
	return []any{%s}
}
`

const FilePrefix = `// Code generated by 'sqlstruct -types=%s -file=%s' in %s; DO NOT EDIT.` +
	"\n// ppid<%d> ctime<%d>\n" +
	"\npackage %s\n\n"

var bs = &bytes.Buffer{}

func GenSQLFn(si *pkg.StructInfo) {
	name := make([]string, 0, len(si.Fields))
	vals := make([]string, 0, len(si.Fields))
	for _, v := range si.Fields {
		tag := v.Get("SQL")
		if tag == "" {
			tag = strings.ToUpper(v.Name)
		}
		name = append(name, "\""+tag+"\"")
		vals = append(vals, "i."+v.Name)
	}

	bs.WriteString(fmt.Sprintf(SQLNames, si.Name, strings.Join(name, ",")))
	bs.WriteString(fmt.Sprintf(SQLValues, si.Name, strings.Join(vals, ",")))
}

func Get(pkg string) []byte {
	bs, err := ioutil.ReadFile(filename)
	if err != nil && !strings.Contains(err.Error(), "no such file or directory") {
		panic(err)
	}

	reg := regexp.MustCompile(`// ppid<(\d+)> ctime<(\d+)>`)
	ret := reg.FindStringSubmatch(string(bs))

	if len(ret) == 0 {
		return []byte(
			fmt.Sprintf(
				FilePrefix,
				typeInput,
				filename,
				time.Now().Format("2006-01-02 15:04:05"),
				os.Getppid(),
				time.Now().Unix(),
				pkg,
			),
		)
	}

	if len(ret) != 3 {
		log.Panicf("%+v", ret)
	}

	ppid, err := strconv.ParseInt(string(ret[1]), 10, 64)
	if err != nil {
		panic(err)
	}

	ctime, err := strconv.ParseInt(string(ret[2]), 10, 64)
	if err != nil {
		panic(err)
	}

	fmt.Printf("ppid<%d>, cur ppid<%d>\n", ppid, os.Getppid())
	if ppid == int64(os.Getppid()) && time.Since(time.Unix(ctime, 0)).Minutes() < 3 {
		return append(bs, '\n', '\n')
	}

	return []byte(
		fmt.Sprintf(
			FilePrefix,
			typeInput,
			filename,
			time.Now().Format("2006-01-02 15:04:05"),
			os.Getppid(),
			time.Now().Unix(),
			pkg,
		),
	)
}

func main() {
	fmt.Printf("ppid<%d>\n", os.Getppid())
	var pkgName string
	filename += ".go"

	for _, v := range types {
		si := pkg.EasyStructInfo(v, ".")

		pkgName = si.Pkg
		if !strings.HasPrefix(filename, "sqlstruct") {
			filename = si.Name + "_sqlstruct.go"
		}

		GenSQLFn(si)
	}
	data := append(Get(pkgName), bs.Bytes()...)

	src, err := format.Source(data)
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
	} else {
		data = src
	}

	ioutil.WriteFile(filename, data, 0644)
}
