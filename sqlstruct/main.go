package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/inysc/astool"
	"golang.org/x/tools/go/packages"
)

var (
	flag_file  = flag.String("file", "sqlstruct.go", "目的文件名")
	flag_types = flag.String("types", "", "结构体名，多个以英文逗号,分割")

	filename    string
	structNames []string

	DB_PTR_NAME = regexp.MustCompile("^DbPtr[A-Z]")
	TARGET_FNS  = []string{
		"SQLNames", "SQLValues",
		"SQLPtrNotNilNames", "SQLPtrNotNilValues",
		"SQLPtrNotPtrNames", "SQLPtrNotPtrValues",
	}
)

const (
	SQLNames           = `func (i *%s) SQLNames() []string { return []string{%s} }` + "\n"
	SQLValues          = `func (i *%s) SQLValues() []interface{} { return []interface{}{%s} }` + "\n"
	SQLPtrNotNilNames  = `func (i *%s) SQLPtrNotNilNames() []string { %s }` + "\n"
	SQLPtrNotNilValues = `func (i *%s) SQLPtrNotNilValues() []interface{} { %s }` + "\n"
	SQLPtrNotPtrNames  = `func (i *%s) SQLPtrNotPtrNames() []string { return []string{%s} }` + "\n"
	SQLPtrNotPtrValues = `func (i *%s) SQLPtrNotPtrValues() []interface{} { return []interface{}{%s} }` + "\n"
)

func judgeVar(filed string) bool   { return false }
func judgeMethod(meth string) bool { return astool.In(TARGET_FNS, meth) }

func main() {
	flag.Parse()
	log.SetFlags(log.Lshortfile)

	// 处理输入参数
	filename = *flag_file
	if !strings.HasSuffix(filename, ".go") {
		filename += ".go"
	}
	structNames = strings.Split(*flag_types, ",")
	if len(structNames) == 0 {
		log.Fatal("not found structNames")
	}

	// 解析目的包
	pkgs, err := packages.Load(&packages.Config{Mode: packages.NeedTypes}, ".")
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatal("len(pkgs) != 1")
	}
	pkg := pkgs[0]

	// 处理目的文件
	// 如果目的文件已存在就清除相关结构体的方法
	// 不存在就写入一些基本信息
	buff := bytes.Buffer{}
	file, err := os.ReadFile(*flag_file)
	if err != nil && !errors.Is(err, os.ErrNotExist) {
		log.Fatal(err)
	}
	if len(file) == 0 {
		buff.WriteString("// Code generated by invalid. DO NOT EDIT.\n")
		buff.WriteString("package " + pkg.Name + "\n")
	} else {
		buff.Write(astool.RemoveBytes(file, structNames, judgeVar, judgeMethod)) // 移除目标文件中相关方法
	}

	// 遍历结构体及其字段
	for _, structName := range structNames {
		obj := pkg.Types.Scope().Lookup(structName)
		if obj == nil {
			log.Fatal("no found " + structName)
		}
		named, ok := obj.Type().(*types.Named)
		if !ok {
			log.Fatal("can not find a named type called " + structName)
		}
		st, ok := named.Underlying().(*types.Struct)
		if !ok {
			log.Fatal(structName + " is not a struct")
		}
		fieldTags := []string{}
		fieldNames := []string{}
		ptrFieldName := []string{}
		notPtrFieldName := []string{}

		needPtr := DB_PTR_NAME.MatchString(structName)
		for i := 0; i < st.NumFields(); i++ {
			field := st.Field(i)
			fieldName := field.Name()
			fieldTag := reflect.StructTag(st.Tag(i))

			if !field.Exported() { // 不处理私有字段
				continue
			}

			// 解析 tag 信息、字段名信息
			if fieldTag.Get("sql") != "" {
				if fieldTag.Get("sql") == "-" { // 标注忽略的字段
					continue
				}
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("sql")))
			} else if fieldTag.Get("SQL") != "" { // 兼容一下过往
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("SQL")))
			} else if fieldTag.Get("db") != "" {
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("db")))
			} else {
				fieldTags = append(fieldTags, strconv.Quote(fieldName))
			}
			fieldNames = append(fieldNames, "i."+fieldName)
			_, ok = field.Type().(*types.Pointer)
			if ok {
				ptrFieldName = append(ptrFieldName, "i."+fieldName)
			} else {
				notPtrFieldName = append(notPtrFieldName, "i."+fieldName)
			}
		}

		// 写入到缓存
		buff.WriteString(fmt.Sprintf(SQLNames, structName, strings.Join(fieldTags, ", ")))
		buff.WriteString(fmt.Sprintf(SQLValues, structName, strings.Join(fieldNames, ", ")))
		if needPtr {
			buff.WriteString(fmt.Sprintf(SQLPtrNotPtrValues, structName, strings.Join(notPtrFieldName, ", ")))

			bufVal := bytes.Buffer{}
			bufName := bytes.Buffer{}
			bufVal.WriteString("ret := []interface{}{}\n")
			bufName.WriteString("ret := []string{}\n")
			template_prt := `if %[1]s != nil { ret = append(ret, %[1]s) }` + "\n"
			template_name := `if %[1]s != nil { ret = append(ret, %[1]s) }` + "\n"
			for _, v := range ptrFieldName {
				bufVal.WriteString(fmt.Sprintf(template_prt, v))
				bufName.WriteString(fmt.Sprintf(template_name, v))
			}
			bufVal.WriteString("return ret")
			bufName.WriteString("return ret")
			buff.WriteString(fmt.Sprintf(SQLPtrNotNilNames, structName, bufName.Bytes()))
			buff.WriteString(fmt.Sprintf(SQLPtrNotNilValues, structName, bufVal.Bytes()))
		}
		buff.WriteByte('\n')
	}

	// 格式化代码，并写入到文件
	buf, err := format.Source(buff.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		file = buff.Bytes()
	} else {
		file = buf
	}
	err = os.WriteFile(*flag_file, file, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
