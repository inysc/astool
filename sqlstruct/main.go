package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	flag_file  = flag.String("file", "sqlstruct.go", "目的文件名")
	flag_types = flag.String("types", "", "结构体名，多个以英文逗号,分割")

	filename    string
	structNames []string

	DB_PTR_NAME = regexp.MustCompile("^DbPtr[A-Z]")
	TARGET_FNS  = []string{"SQLNames", "SQLValues", "SQLPtrNotNil", "SQLPtrNotPtr"}
)

const (
	template_SQLNames     = `func (i *%s) SQLNames() []string { return []string{%s} }` + "\n"
	template_SQLValues    = `func (i *%s) SQLValues() []interface{} { return []interface{}{%s} }` + "\n"
	template_SQLPtrNotNil = `func (i *%s) SQLPtrNotNil() []interface{} { %s }` + "\n"
	template_SQLPtrNotPtr = `func (i *%s) SQLPtrNotPtr() []interface{} {  return []interface{}{%s} }` + "\n"
)

func main() {
	flag.Parse()
	log.SetFlags(log.Lshortfile)

	// 处理输入参数
	filename = *flag_file
	if !strings.HasSuffix(filename, ".go") {
		filename += ".go"
	}
	structNames = strings.Split(*flag_types, ",")
	if len(structNames) == 0 {
		log.Fatal("not found structNames")
	}

	// 解析目的包
	pkgs, err := packages.Load(&packages.Config{Mode: packages.NeedTypes}, ".")
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatal("len(pkgs) != 1")
	}
	pkg := pkgs[0]

	// 处理目的文件
	// 如果目的文件已存在就清除相关结构体的方法
	// 不存在就写入一些基本信息
	buff := bytes.Buffer{}
	file, err := os.ReadFile(*flag_file)
	if err != nil && !errors.Is(err, os.ErrNotExist) {
		log.Fatal(err)
	}
	if len(file) == 0 {
		buff.WriteString("// Code generated by invalid. DO NOT EDIT.\n")
		buff.WriteString("package " + pkg.Name + "\n")
	} else {
		buff.Write(RemoveFuncs(file, structNames...)) // 移除目标文件中相关方法
	}

	// 遍历结构体及其字段
	for _, structName := range structNames {
		obj := pkg.Types.Scope().Lookup(structName)
		if obj == nil {
			log.Fatal("no found " + structName)
		}
		named, ok := obj.Type().(*types.Named)
		if !ok {
			log.Fatal("can not find a named type called " + structName)
		}
		st, ok := named.Underlying().(*types.Struct)
		if !ok {
			log.Fatal(structName + " is not a struct")
		}
		fieldTags := []string{}
		fieldNames := []string{}
		ptrFieldName := []string{}
		notPtrFieldName := []string{}

		needPtr := DB_PTR_NAME.MatchString(structName)
		for i := 0; i < st.NumFields(); i++ {
			field := st.Field(i)
			fieldName := field.Name()
			fieldTag := reflect.StructTag(st.Tag(i))

			if !field.Exported() { // 不处理私有字段
				continue
			}

			// 解析 tag 信息、字段名信息
			if fieldTag.Get("sql") != "" {
				if fieldTag.Get("sql") == "-" { // 标注忽略的字段
					continue
				}
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("sql")))
			} else if fieldTag.Get("SQL") != "" { // 兼容一下过往
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("SQL")))
			} else if fieldTag.Get("db") != "" {
				fieldTags = append(fieldTags, strconv.Quote(fieldTag.Get("db")))
			} else {
				fieldTags = append(fieldTags, strconv.Quote(fieldName))
			}
			fieldNames = append(fieldNames, "i."+fieldName)
			_, ok = field.Type().(*types.Pointer)
			if ok {
				ptrFieldName = append(ptrFieldName, "i."+fieldName)
			} else {
				notPtrFieldName = append(notPtrFieldName, "i."+fieldName)
			}
		}

		// 写入到缓存
		buff.WriteString(fmt.Sprintf(template_SQLNames, structName, strings.Join(fieldTags, ", ")))
		buff.WriteString(fmt.Sprintf(template_SQLValues, structName, strings.Join(fieldNames, ", ")))
		if needPtr {
			buff.WriteString(fmt.Sprintf(template_SQLPtrNotPtr, structName, strings.Join(notPtrFieldName, ", ")))

			buf := bytes.Buffer{}
			buf.WriteString("ret := []interface{}{}\n")
			template_prt := `if %[1]s != nil { ret = append(ret, %[1]s) }` + "\n"
			for _, v := range ptrFieldName {
				buf.WriteString(fmt.Sprintf(template_prt, v))
			}
			buf.WriteString("return ret")
			buff.WriteString(fmt.Sprintf(template_SQLPtrNotNil, structName, buf.Bytes()))
		}
		buff.WriteByte('\n')
	}

	// 格式化代码，并写入到文件
	buf, err := format.Source(buff.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		file = buff.Bytes()
	} else {
		file = buf
	}
	err = os.WriteFile(*flag_file, file, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

type Pair struct {
	First  token.Pos
	Second token.Pos
}

func RemoveFuncs(src []byte, structNames ...string) []byte {
	file, err := parser.ParseFile(token.NewFileSet(), "", src, parser.AllErrors|parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	var ps []Pair
	for _, v := range file.Decls {
		switch fn := v.(type) {
		case *ast.FuncDecl:
			if fn.Recv == nil {
				continue
			}
			if !In(TARGET_FNS, fn.Name.Name) {
				continue
			}
			for _, v := range fn.Recv.List {
				switch expr := v.Type.(type) {
				case *ast.StarExpr:
					switch x := expr.X.(type) {
					case *ast.Ident:
						if In(structNames, x.Name) {
							ps = append(ps, Pair{fn.Pos() - 1, fn.End()})
							break
						}
					case *ast.IndexExpr: // 泛型
						if In(structNames, x.X.(*ast.Ident).Name) {
							ps = append(ps, Pair{fn.Pos() - 1, fn.End()})
							break
						}
					}
				}
			}
		}
	}
	// 去除 content 指定部分
	for i := len(ps) - 1; i >= 0; i-- {
		fornt := src[:ps[i].First]
		end := src[ps[i].Second:]
		src = append(fornt, end...)
	}
	return src
}

func In(vals []string, target string) bool {
	for _, v := range vals {
		if v == target {
			return true
		}
	}
	return false
}

