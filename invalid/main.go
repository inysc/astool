package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"github.com/inysc/astool"
	"github.com/inysc/astool/invalid/rule"
)

var (
	input_file   = flag.String("file", "", "写入到的文件名")
	input_tags   = flag.String("tags", "", "指定 build tag 的")
	input_types  = flag.String("types", "", "待生成校验方法的结构体名")
	input_import = flag.String("imports", "", "规则中使用到的包")

	filename string
	tags     []string
	types    []string
	Imports  []string

	hasTimeFunc = false
	pkg         *astool.Package

	CONTENT = astool.NewBytes() // 生成的内容
)

func init() {
	flag.Parse()

	tags = strings.Split(*input_tags, ",")
	types = strings.Split(*input_types, ",")
	Imports = strings.Split(*input_import, ",")
	if *input_file == "" {
		*input_file = types[0]
	}
	filename = *input_file
	if !strings.HasSuffix(filename, ".go") {
		if !strings.Contains(filename, "invalid") {
			filename += "_invalid"
		}
		filename += ".go"
	}
}

func main() {
	log.SetFlags(log.Llongfile)

	pkg = astool.EasyStructInfos(".", types, tags...)
	hasTimeFunc = astool.ExistFunc(pkg.Pkg, "mustTimeParse")

	for _, name := range types {
		Parse(pkg.Structs[name])
	}

	// 写入到文件
	SaveFile()
}

func Parse(st *astool.StructInfo) {
	fns := []string{}
	for _, v := range st.Fields {
		str := rule.NewRule(st.Name, v)
		if str != "" {
			CONTENT.WriteString(str)
			fns = append(fns, fmt.Sprintf("i._%s_Invalid_%s", st.Name, v.Name))
		}
	}
	CONTENT.Pf("func (i *%s) Invalid(tags ...string) (err error) {", st.Name)
	CONTENT.P("    if i == nil {")
	CONTENT.P("        return nil")
	CONTENT.P("    }")
	CONTENT.P("    for _, fn := range []func([]string) error {")
	CONTENT.P(strings.Join(fns, ",\n"), ",")
	CONTENT.P("    } {")
	CONTENT.P("        if err := fn(tags); err != nil {")
	CONTENT.P("            return err")
	CONTENT.P("        }")
	CONTENT.P("    }")
	CONTENT.P("    return nil")
	CONTENT.P("}\n")
}

func judgeVar(target string) bool    { return strings.HasPrefix(target, "_"+target+"_") }
func judgeMethod(target string) bool { return strings.HasPrefix(target, "_"+target+"_Invalid_") }

func SaveFile() {
	// 读取文件
	content := astool.MustReadFile(filename)
	bs := astool.NewBytes()
	if len(content) == 0 {
		bs.P("// Code generated by invalid. DO NOT EDIT.\n")
		bs.Pf("package %s\n", pkg.Pkg.Name)
		bs.P("import (")
		bs.P(`    "errors"`)
		bs.P(`    "fmt"`)
		bs.P(`    "regexp"`)
		bs.P(`    "time"`)
		bs.P(`    "unicode/utf8"`)
		bs.P(")\n")
		bs.P("var (")
		bs.P(`    _ = fmt.Errorf`)
		bs.P(`    _ = regexp.MustCompile`)
		bs.P(`    _ = time.Parse`)
		bs.P(`    _ = errors.New`)
		bs.P(`    _ = utf8.RuneCountInString`)
		bs.P(")\n")
	} else {
		content = astool.RemoveBytes(content, types, judgeVar, judgeMethod)
	}
	bs.P(string(content))
	if !hasTimeFunc {
		bs.P("func mustTimeParse(layout, value string) time.Time {")
		bs.P("    t, err := time.Parse(layout, value)")
		bs.P("    if err != nil {")
		bs.P("        panic(err)")
		bs.P("    }")
		bs.P("    return t")
		bs.P("}\n")
	}
	bs.WriteString(CONTENT.String())

	var src []byte
	src, err := format.Source(bs.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = bs.Bytes()
	}

	err = os.WriteFile(filename, src, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
